{
  "hash": "e0383563f540e7230f51ca5c259ae8f7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 2 : Modélisation des Données\"\ntoc: true\ntoc-depth: 3\nnumber-sections: false\n---\n\n\n\n**Durée : 5 heures** | **Objectif : Concevoir des modèles décisionnels performants et maîtriser le SQL analytique**\n\n---\n\n## 2.1 Introduction à la Modélisation Dimensionnelle\n\n### 2.1.1 Pourquoi Modéliser les Données ?\n\nLa modélisation dimensionnelle est une technique de conception de bases de données optimisée pour l'interrogation et l'analyse de données. Contrairement aux modèles transactionnels (OLTP), les modèles décisionnels (OLAP) privilégient :\n\n**Objectifs de la Modélisation Dimensionnelle :**\n\n| Objectif | Bénéfice | Impact Métier |\n|----------|----------|---------------|\n| **Simplicité** | Schéma intuitif, requêtes faciles | Adoption par les utilisateurs métier |\n| **Performance** | Lectures rapides, agrégations optimisées | Dashboards temps réel |\n| **Flexibilité** | Ajout facile de dimensions | Évolutivité du système |\n| **Historisation** | Conservation de l'historique complet | Analyses de tendances |\n\n### 2.1.2 Concepts Fondamentaux\n\n#### **Faits vs Dimensions**\n\n**Les FAITS (Facts)** représentent les événements mesurables de l'entreprise :\n\n| Caractéristique | Description | Exemple |\n|----------------|-------------|---------|\n| **Nature** | Événements quantifiables | Vente, Achat, Paiement, Livraison |\n| **Contenu** | Métriques numériques | Montant, Quantité, Coût, Durée |\n| **Granularité** | Niveau de détail | Par transaction, par ligne de commande |\n| **Volumétrie** | Forte (millions de lignes) | Table de faits = 80-90% du volume |\n\n**Les DIMENSIONS (Dimensions)** fournissent le contexte pour analyser les faits :\n\n| Caractéristique | Description | Exemple |\n|----------------|-------------|---------|\n| **Nature** | Qui, Quoi, Où, Quand, Comment | Client, Produit, Magasin, Temps |\n| **Contenu** | Attributs descriptifs | Nom, Catégorie, Adresse, Hiérarchies |\n| **Granularité** | Niveau le plus fin | Client individuel, Produit SKU |\n| **Volumétrie** | Faible (milliers de lignes) | Tables légères |\n\n**Visualisation Conceptuelle :**\n\n```{mermaid}\ngraph LR\n    D1[Dimension<br/>Temps] --> F[Table de Faits<br/>VENTES]\n    D2[Dimension<br/>Produit] --> F\n    D3[Dimension<br/>Client] --> F\n    D4[Dimension<br/>Magasin] --> F\n    \n    F --> M1[Mesure:<br/>Montant_Vente]\n    F --> M2[Mesure:<br/>Quantité]\n    F --> M3[Mesure:<br/>Coût]\n    \n    style F fill:#2E86AB\n    style D1 fill:#F18F01\n    style D2 fill:#F18F01\n    style D3 fill:#F18F01\n    style D4 fill:#F18F01\n```\n\n#### **Clés et Relations**\n\n**Clés Primaires et Étrangères :**\n\n```{mermaid}\nerDiagram\n    DIM_TEMPS {\n        int Date_Key PK\n        date Date_Complete\n        int Année\n        int Mois\n        string Nom_Mois\n    }\n    \n    DIM_PRODUIT {\n        int Produit_Key PK\n        string SKU\n        string Nom_Produit\n        string Catégorie\n    }\n    \n    FACT_VENTES {\n        int Vente_Key PK\n        int Date_Key FK\n        int Produit_Key FK\n        int Client_Key FK\n        decimal Montant_HT\n        int Quantité\n    }\n    \n    DIM_CLIENT {\n        int Client_Key PK\n        string Code_Client\n        string Nom\n        string Ville\n    }\n    \n    DIM_TEMPS ||--o{ FACT_VENTES : \"\"\n    DIM_PRODUIT ||--o{ FACT_VENTES : \"\"\n    DIM_CLIENT ||--o{ FACT_VENTES : \"\"\n```\n\n**Types de Clés :**\n\n| Type de Clé | Rôle | Exemple |\n|-------------|------|---------|\n| **Clé Naturelle** | Identifiant métier d'origine | SKU produit, Code client |\n| **Clé de Substitution (Surrogate Key)** | Clé technique générée (entier auto-incrémenté) | Produit_Key (1, 2, 3...) |\n| **Clé Étrangère** | Référence vers une dimension | Date_Key dans la table de faits |\n| **Clé Composite** | Combinaison de plusieurs colonnes | (Date, Magasin, Produit) |\n\n**Pourquoi utiliser des clés de substitution ?**\n\n✅ Performance : entiers plus rapides que des strings  \n✅ Stabilité : indépendant des changements métier  \n✅ Historisation : gérer les évolutions (SCD Type 2)  \n✅ Simplicité : pas de clés composites complexes\n\n---\n\n## 2.2 Les Modèles Dimensionnels\n\n### 2.2.1 Le Modèle en Étoile (Star Schema)\n\nLe modèle en étoile est le plus répandu en Business Intelligence. Il tire son nom de sa forme : une table de faits centrale entourée de tables de dimensions.\n\n**Caractéristiques :**\n\n| Aspect | Description |\n|--------|-------------|\n| **Structure** | 1 table de faits au centre + N dimensions dénormalisées |\n| **Normalisation** | Dimensions dénormalisées (redondance acceptée) |\n| **Requêtes** | Simples (1-2 jointures maximum) |\n| **Performance** | Excellente (peu de jointures) |\n| **Maintenance** | Facile à comprendre et maintenir |\n\n**Exemple Concret : Modèle Ventes**\n\n```{mermaid}\nerDiagram\n    FACT_VENTES {\n        bigint Vente_Key PK\n        int Date_Key FK\n        int Produit_Key FK\n        int Client_Key FK\n        int Magasin_Key FK\n        int Vendeur_Key FK\n        decimal Montant_HT\n        decimal Montant_TTC\n        decimal Coût\n        int Quantité\n        decimal Remise_Pourcent\n    }\n    \n    DIM_DATE {\n        int Date_Key PK\n        date Date_Complete\n        int Année\n        int Trimestre\n        int Mois\n        int Semaine\n        string Nom_Mois\n        string Jour_Semaine\n        boolean Est_Weekend\n        boolean Est_Férié\n    }\n    \n    DIM_PRODUIT {\n        int Produit_Key PK\n        string SKU\n        string Nom_Produit\n        string Catégorie\n        string Sous_Catégorie\n        string Marque\n        decimal Prix_Catalogue\n        string Fournisseur\n    }\n    \n    DIM_CLIENT {\n        int Client_Key PK\n        string Code_Client\n        string Nom\n        string Prénom\n        string Email\n        string Téléphone\n        string Adresse\n        string Code_Postal\n        string Ville\n        string Pays\n        string Segment\n        date Date_Première_Commande\n    }\n    \n    DIM_MAGASIN {\n        int Magasin_Key PK\n        string Code_Magasin\n        string Nom_Magasin\n        string Adresse\n        string Ville\n        string Région\n        int Surface_M2\n        date Date_Ouverture\n        string Type_Magasin\n    }\n    \n    DIM_VENDEUR {\n        int Vendeur_Key PK\n        string Matricule\n        string Nom\n        string Prénom\n        int Magasin_Key FK\n        date Date_Embauche\n        string Statut\n    }\n    \n    DIM_DATE ||--o{ FACT_VENTES : \"se produit le\"\n    DIM_PRODUIT ||--o{ FACT_VENTES : \"concerne\"\n    DIM_CLIENT ||--o{ FACT_VENTES : \"est acheté par\"\n    DIM_MAGASIN ||--o{ FACT_VENTES : \"a lieu dans\"\n    DIM_VENDEUR ||--o{ FACT_VENTES : \"est réalisée par\"\n```\n\n**Script SQL de Création :**\n\n```sql\n-- Table de Faits VENTES\nCREATE TABLE FACT_Ventes (\n    Vente_Key BIGINT PRIMARY KEY IDENTITY(1,1),\n    Date_Key INT NOT NULL,\n    Produit_Key INT NOT NULL,\n    Client_Key INT NOT NULL,\n    Magasin_Key INT NOT NULL,\n    Vendeur_Key INT NOT NULL,\n    Montant_HT DECIMAL(10,2) NOT NULL,\n    Montant_TTC DECIMAL(10,2) NOT NULL,\n    Coût DECIMAL(10,2),\n    Quantité INT NOT NULL,\n    Remise_Pourcent DECIMAL(5,2) DEFAULT 0,\n    \n    -- Clés étrangères\n    CONSTRAINT FK_Ventes_Date FOREIGN KEY (Date_Key) \n        REFERENCES DIM_Date(Date_Key),\n    CONSTRAINT FK_Ventes_Produit FOREIGN KEY (Produit_Key) \n        REFERENCES DIM_Produit(Produit_Key),\n    CONSTRAINT FK_Ventes_Client FOREIGN KEY (Client_Key) \n        REFERENCES DIM_Client(Client_Key),\n    CONSTRAINT FK_Ventes_Magasin FOREIGN KEY (Magasin_Key) \n        REFERENCES DIM_Magasin(Magasin_Key),\n    CONSTRAINT FK_Ventes_Vendeur FOREIGN KEY (Vendeur_Key) \n        REFERENCES DIM_Vendeur(Vendeur_Key)\n);\n\n-- Index pour améliorer les performances\nCREATE INDEX IX_Ventes_Date ON FACT_Ventes(Date_Key);\nCREATE INDEX IX_Ventes_Produit ON FACT_Ventes(Produit_Key);\nCREATE INDEX IX_Ventes_Client ON FACT_Ventes(Client_Key);\nCREATE INDEX IX_Ventes_Magasin ON FACT_Ventes(Magasin_Key);\n\n-- Table Dimension DATE\nCREATE TABLE DIM_Date (\n    Date_Key INT PRIMARY KEY,\n    Date_Complete DATE NOT NULL UNIQUE,\n    Année INT NOT NULL,\n    Trimestre INT NOT NULL,\n    Mois INT NOT NULL,\n    Semaine INT NOT NULL,\n    Nom_Mois VARCHAR(20) NOT NULL,\n    Jour_Semaine VARCHAR(20) NOT NULL,\n    Numéro_Jour_Semaine INT NOT NULL,\n    Est_Weekend BIT NOT NULL DEFAULT 0,\n    Est_Férié BIT NOT NULL DEFAULT 0,\n    Nom_Férié VARCHAR(50) NULL\n);\n\n-- Exemple de remplissage dimension Date\nINSERT INTO DIM_Date (Date_Key, Date_Complete, Année, Trimestre, Mois, Semaine, \n                      Nom_Mois, Jour_Semaine, Numéro_Jour_Semaine, Est_Weekend)\nSELECT \n    CAST(CONVERT(VARCHAR, d, 112) AS INT) AS Date_Key,\n    d AS Date_Complete,\n    YEAR(d) AS Année,\n    DATEPART(QUARTER, d) AS Trimestre,\n    MONTH(d) AS Mois,\n    DATEPART(WEEK, d) AS Semaine,\n    DATENAME(MONTH, d) AS Nom_Mois,\n    DATENAME(WEEKDAY, d) AS Jour_Semaine,\n    DATEPART(WEEKDAY, d) AS Numéro_Jour_Semaine,\n    CASE WHEN DATEPART(WEEKDAY, d) IN (1,7) THEN 1 ELSE 0 END AS Est_Weekend\nFROM (\n    SELECT DATEADD(DAY, number, '2020-01-01') AS d\n    FROM master..spt_values\n    WHERE type = 'P' AND number < DATEDIFF(DAY, '2020-01-01', '2030-12-31')\n) AS Dates;\n```\n\n### 2.2.2 Le Modèle en Flocon (Snowflake Schema)\n\nLe modèle en flocon est une extension du modèle en étoile où les dimensions sont normalisées (décomposées en sous-dimensions).\n\n**Comparaison Étoile vs Flocon :**\n\n| Critère | Étoile (Star) | Flocon (Snowflake) |\n|---------|---------------|---------------------|\n| **Normalisation** | Dénormalisé | Normalisé (3NF) |\n| **Redondance** | Oui (attributs répétés) | Non (tables séparées) |\n| **Nombre de tables** | Moins de tables | Plus de tables |\n| **Requêtes** | Simples (peu de JOIN) | Complexes (nombreux JOIN) |\n| **Performance lecture** | Très rapide | Plus lente |\n| **Stockage** | Plus d'espace | Moins d'espace |\n| **Maintenance** | Facile | Plus complexe |\n| **Usage recommandé** | BI classique, Power BI | Très gros volumes, économie stockage |\n\n**Exemple : Dimension Produit Normalisée**\n\n**Modèle Étoile (Dénormalisé) :**\n```\nDIM_PRODUIT\n├── Produit_Key\n├── SKU\n├── Nom_Produit\n├── Catégorie          ← Redondance\n├── Sous_Catégorie     ← Redondance\n├── Marque             ← Redondance\n└── Fournisseur        ← Redondance\n```\n\n**Modèle Flocon (Normalisé) :**\n```{mermaid}\nerDiagram\n    DIM_PRODUIT {\n        int Produit_Key PK\n        string SKU\n        string Nom_Produit\n        int Catégorie_Key FK\n        int Marque_Key FK\n        int Fournisseur_Key FK\n    }\n    \n    DIM_CATEGORIE {\n        int Catégorie_Key PK\n        string Nom_Catégorie\n        string Nom_Sous_Catégorie\n        int Département_Key FK\n    }\n    \n    DIM_DEPARTEMENT {\n        int Département_Key PK\n        string Nom_Département\n        string Code_Département\n    }\n    \n    DIM_MARQUE {\n        int Marque_Key PK\n        string Nom_Marque\n        string Pays_Origine\n    }\n    \n    DIM_FOURNISSEUR {\n        int Fournisseur_Key PK\n        string Nom_Fournisseur\n        string Pays\n        string Contact\n    }\n    \n    DIM_PRODUIT }o--|| DIM_CATEGORIE : \"appartient à\"\n    DIM_CATEGORIE }o--|| DIM_DEPARTEMENT : \"fait partie de\"\n    DIM_PRODUIT }o--|| DIM_MARQUE : \"possède\"\n    DIM_PRODUIT }o--|| DIM_FOURNISSEUR : \"fourni par\"\n```\n\n**Quand utiliser le Flocon ?**\n\n✅ Très gros volumes de dimensions (> 10 millions de lignes)  \n✅ Contraintes de stockage importantes  \n✅ Nécessité de maintenir des référentiels séparés  \n✅ Complexité analytique justifiée\n\n❌ Pour la plupart des projets BI : **privilégier l'Étoile** pour sa simplicité\n\n### 2.2.3 Le Modèle en Constellation (Galaxy Schema)\n\nLe modèle en constellation combine plusieurs modèles en étoile partageant des dimensions communes.\n\n**Cas d'Usage :**\n- Plusieurs processus métier analysés simultanément\n- Dimensions partagées (Temps, Client, Produit)\n- Analyses cross-processus\n\n**Exemple : Ventes + Achats + Stocks**\n\n```{mermaid}\nerDiagram\n    FACT_VENTES {\n        bigint Vente_Key PK\n        int Date_Key FK\n        int Produit_Key FK\n        int Client_Key FK\n        decimal Montant_HT\n        int Quantité_Vendue\n    }\n    \n    FACT_ACHATS {\n        bigint Achat_Key PK\n        int Date_Key FK\n        int Produit_Key FK\n        int Fournisseur_Key FK\n        decimal Coût_Unitaire\n        int Quantité_Achetée\n    }\n    \n    FACT_STOCKS {\n        bigint Stock_Key PK\n        int Date_Key FK\n        int Produit_Key FK\n        int Magasin_Key FK\n        int Quantité_Stock\n        decimal Valeur_Stock\n    }\n    \n    DIM_DATE {\n        int Date_Key PK\n        date Date_Complete\n    }\n    \n    DIM_PRODUIT {\n        int Produit_Key PK\n        string Nom_Produit\n    }\n    \n    DIM_CLIENT {\n        int Client_Key PK\n        string Nom_Client\n    }\n    \n    DIM_FOURNISSEUR {\n        int Fournisseur_Key PK\n        string Nom_Fournisseur\n    }\n    \n    DIM_MAGASIN {\n        int Magasin_Key PK\n        string Nom_Magasin\n    }\n    \n    DIM_DATE ||--o{ FACT_VENTES : \"\"\n    DIM_DATE ||--o{ FACT_ACHATS : \"\"\n    DIM_DATE ||--o{ FACT_STOCKS : \"\"\n    \n    DIM_PRODUIT ||--o{ FACT_VENTES : \"\"\n    DIM_PRODUIT ||--o{ FACT_ACHATS : \"\"\n    DIM_PRODUIT ||--o{ FACT_STOCKS : \"\"\n    \n    DIM_CLIENT ||--o{ FACT_VENTES : \"\"\n    DIM_FOURNISSEUR ||--o{ FACT_ACHATS : \"\"\n    DIM_MAGASIN ||--o{ FACT_STOCKS : \"\"\n```\n\n**Avantages :**\n- Réutilisation des dimensions (cohérence)\n- Analyses croisées (ventes vs achats vs stocks)\n- Maintenance simplifiée des référentiels\n\n**Requête d'Analyse Cross-Processus :**\n\n```sql\n-- Analyse de la Marge et de la Rotation des Stocks\nSELECT \n    p.Nom_Produit,\n    p.Catégorie,\n    SUM(v.Montant_HT) AS CA_Total,\n    SUM(a.Quantité_Achetée * a.Coût_Unitaire) AS Coût_Total,\n    SUM(v.Montant_HT) - SUM(a.Quantité_Achetée * a.Coût_Unitaire) AS Marge_Brute,\n    AVG(s.Quantité_Stock) AS Stock_Moyen,\n    CASE \n        WHEN AVG(s.Quantité_Stock) > 0 \n        THEN SUM(v.Quantité_Vendue) / AVG(s.Quantité_Stock) \n        ELSE 0 \n    END AS Taux_Rotation\nFROM DIM_Produit p\nJOIN FACT_Ventes v ON p.Produit_Key = v.Produit_Key\nJOIN FACT_Achats a ON p.Produit_Key = a.Produit_Key\nJOIN FACT_Stocks s ON p.Produit_Key = s.Produit_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nWHERE d.Année = 2024\nGROUP BY p.Nom_Produit, p.Catégorie\nORDER BY Marge_Brute DESC;\n```\n\n---\n\n## 2.3 Techniques d'Historisation (SCD - Slowly Changing Dimensions)\n\n### 2.3.1 Le Défi de l'Historisation\n\nDans les systèmes décisionnels, il est crucial de conserver l'historique des changements pour analyser les données dans leur contexte temporel.\n\n**Exemple :** Un client change de région → Comment analyser les ventes historiques par région ?\n\n### 2.3.2 Les 6 Types de SCD\n\n```{mermaid}\ngraph TB\n    A[SCD Types] --> B[Type 0 : Fixe]\n    A --> C[Type 1 : Écrasement]\n    A --> D[Type 2 : Historisation]\n    A --> E[Type 3 : Colonnes supplémentaires]\n    A --> F[Type 4 : Table d'historique]\n    A --> G[Type 6 : Hybride 1+2+3]\n    \n    style D fill:#2E86AB\n    style G fill:#F18F01\n```\n\n#### **Type 0 : Attribut Fixe**\n- Pas de mise à jour, valeur conservée telle qu'à la création\n- **Usage** : Date de naissance, code postal d'origine\n\n#### **Type 1 : Écrasement (Overwrite)**\n- La nouvelle valeur remplace l'ancienne sans trace\n- **Usage** : Correction d'erreurs, données non historisées\n\n#### **Type 2 : Historisation Complète**\n- Création d'une nouvelle ligne avec nouvelles dates de validité\n- **Usage** : Changements critiques (région client, catégorie produit)\n\n#### **Type 3 : Colonnes Supplémentaires**\n- Conservation de l'ancienne valeur dans une colonne séparée\n- **Usage** : Historisation limitée (seulement la dernière valeur)\n\n#### **Type 4 : Table d'Historique Séparée**\n- Table courante + table d'historique des changements\n- **Usage** : Dimensions très volumineuses\n\n#### **Type 6 : Hybride (1+2+3)**\n- Combinaison des approches pour différents attributs\n\n### 2.3.3 Implémentation SCD Type 2 (Recommandé)\n\n**Structure de Table SCD Type 2 :**\n\n```sql\nCREATE TABLE DIM_Client (\n    Client_Key INT PRIMARY KEY IDENTITY(1,1),\n    Code_Client VARCHAR(20) NOT NULL,          -- Clé naturelle\n    Nom VARCHAR(100) NOT NULL,\n    Prénom VARCHAR(100) NOT NULL,\n    Email VARCHAR(255),\n    Ville VARCHAR(100),\n    Région VARCHAR(100),\n    \n    -- Colonnes de gestion SCD Type 2\n    Date_Début DATE NOT NULL,                  -- Début de validité\n    Date_Fin DATE NOT NULL,                    -- Fin de validité\n    Version_Active BIT NOT NULL DEFAULT 1,     -- Version courante\n    Hash_Attributs BINARY(16)                  -- Pour détection changements\n);\n\n-- Index pour performances\nCREATE INDEX IX_Client_Code ON DIM_Client(Code_Client);\nCREATE INDEX IX_Client_Dates ON DIM_Client(Date_Début, Date_Fin);\nCREATE INDEX IX_Client_Active ON DIM_Client(Version_Active);\n```\n\n**Processus ETL pour SCD Type 2 :**\n\n```sql\n-- Étape 1 : Désactiver les enregistrements modifiés\nUPDATE cible\nSET \n    Date_Fin = DATEADD(DAY, -1, CAST(GETDATE() AS DATE)),\n    Version_Active = 0\nFROM DIM_Client cible\nINNER JOIN STG_Client source ON cible.Code_Client = source.Code_Client\nWHERE cible.Version_Active = 1\n  AND cible.Hash_Attributs <> source.Hash_Attributs;\n\n-- Étape 2 : Insérer les nouvelles versions\nINSERT INTO DIM_Client (\n    Code_Client, Nom, Prénom, Email, Ville, Région,\n    Date_Début, Date_Fin, Version_Active, Hash_Attributs\n)\nSELECT \n    source.Code_Client,\n    source.Nom,\n    source.Prénom,\n    source.Email,\n    source.Ville,\n    source.Région,\n    CAST(GETDATE() AS DATE) AS Date_Début,\n    '9999-12-31' AS Date_Fin,\n    1 AS Version_Active,\n    source.Hash_Attributs\nFROM STG_Client source\nWHERE NOT EXISTS (\n    SELECT 1 FROM DIM_Client c \n    WHERE c.Code_Client = source.Code_Client \n    AND c.Version_Active = 1\n);\n```\n\n**Requête avec contexte historique :**\n\n```sql\n-- Ventes par région client au moment de la vente\nSELECT \n    c.Nom,\n    c.Région_Historique,  -- Région au moment de la vente\n    SUM(v.Montant_HT) AS CA_Total\nFROM FACT_Ventes v\nJOIN DIM_Client c ON v.Client_Key = c.Client_Key\n                AND v.Date_Key BETWEEN c.Date_Début_Key AND c.Date_Fin_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nWHERE d.Année = 2024\nGROUP BY c.Nom, c.Région_Historique;\n```\n\n---\n\n## 2.4 SQL Analytique pour la BI\n\n### 2.4.1 Fonctions Fenêtrées (Window Functions)\n\nLes fonctions fenêtrées permettent des calculs avancés sans regrouper les lignes.\n\n#### **RANK, DENSE_RANK, ROW_NUMBER**\n\n```sql\n-- Classement des produits par CA\nSELECT\n    p.Nom_Produit,\n    p.Catégorie,\n    SUM(v.Montant_HT) AS CA_Total,\n    RANK() OVER (ORDER BY SUM(v.Montant_HT) DESC) AS Classement_Rank,\n    DENSE_RANK() OVER (ORDER BY SUM(v.Montant_HT) DESC) AS Classement_Dense_Rank,\n    ROW_NUMBER() OVER (ORDER BY SUM(v.Montant_HT) DESC) AS Classement_Row_Number,\n    -- Classement par catégorie\n    RANK() OVER (PARTITION BY p.Catégorie ORDER BY SUM(v.Montant_HT) DESC) AS Classement_Catégorie\nFROM FACT_Ventes v\nJOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nWHERE d.Année = 2024\nGROUP BY p.Nom_Produit, p.Catégorie;\n```\n\n#### **LAG, LEAD pour Analyse Temporelle**\n\n```sql\n-- Analyse de l'évolution mensuelle du CA\nWITH CA_Mensuel AS (\n    SELECT\n        d.Année,\n        d.Mois,\n        SUM(v.Montant_HT) AS CA_Mois,\n        LAG(SUM(v.Montant_HT)) OVER (ORDER BY d.Année, d.Mois) AS CA_Mois_Precedent,\n        LEAD(SUM(v.Montant_HT)) OVER (ORDER BY d.Année, d.Mois) AS CA_Mois_Suivant\n    FROM FACT_Ventes v\n    JOIN DIM_Date d ON v.Date_Key = d.Date_Key\n    GROUP BY d.Année, d.Mois\n)\nSELECT\n    Année,\n    Mois,\n    CA_Mois,\n    CA_Mois_Precedent,\n    CASE \n        WHEN CA_Mois_Precedent > 0 \n        THEN (CA_Mois - CA_Mois_Precedent) / CA_Mois_Precedent * 100 \n        ELSE NULL \n    END AS Evolution_Pourcent,\n    CA_Mois_Suivant\nFROM CA_Mensuel\nORDER BY Année, Mois;\n```\n\n### 2.4.2 Agrégations Avancées\n\n#### **ROLLUP et CUBE**\n\n```sql\n-- Agrégations hiérarchiques avec ROLLUP\nSELECT\n    COALESCE(p.Catégorie, 'TOTAL') AS Catégorie,\n    COALESCE(p.Sous_Catégorie, 'SOUS-TOTAL') AS Sous_Catégorie,\n    SUM(v.Montant_HT) AS CA_Total,\n    SUM(v.Quantité) AS Quantité_Total\nFROM FACT_Ventes v\nJOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nWHERE d.Année = 2024\nGROUP BY ROLLUP(p.Catégorie, p.Sous_Catégorie)\nORDER BY p.Catégorie, p.Sous_Catégorie;\n\n-- Agrégations multidimensionnelles avec CUBE\nSELECT\n    COALESCE(p.Catégorie, 'TOUTES CATÉGORIES') AS Catégorie,\n    COALESCE(m.Région, 'TOUTES RÉGIONS') AS Région,\n    SUM(v.Montant_HT) AS CA_Total\nFROM FACT_Ventes v\nJOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\nJOIN DIM_Magasin m ON v.Magasin_Key = m.Magasin_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nWHERE d.Trimestre = 1 AND d.Année = 2024\nGROUP BY CUBE(p.Catégorie, m.Région);\n```\n\n#### **Fonctions d'agrégation conditionnelle**\n\n```sql\n-- Analyse des ventes par tranche horaire\nSELECT\n    p.Catégorie,\n    -- Ventes en semaine\n    SUM(CASE WHEN d.Est_Weekend = 0 THEN v.Montant_HT ELSE 0 END) AS CA_Semaine,\n    -- Ventes weekend\n    SUM(CASE WHEN d.Est_Weekend = 1 THEN v.Montant_HT ELSE 0 END) AS CA_Weekend,\n    -- Pourcentage weekend\n    CASE \n        WHEN SUM(v.Montant_HT) > 0 \n        THEN SUM(CASE WHEN d.Est_Weekend = 1 THEN v.Montant_HT ELSE 0 END) / \n             SUM(v.Montant_HT) * 100 \n        ELSE 0 \n    END AS Pourcentage_Weekend,\n    -- Top client par catégorie\n    MAX(CASE WHEN r.Classement = 1 THEN c.Nom END) AS Top_Client\nFROM FACT_Ventes v\nJOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\nJOIN DIM_Date d ON v.Date_Key = d.Date_Key\nJOIN DIM_Client c ON v.Client_Key = c.Client_Key\nJOIN (\n    SELECT \n        p.Produit_Key,\n        c.Client_Key,\n        RANK() OVER (PARTITION BY p.Catégorie ORDER BY SUM(v.Montant_HT) DESC) AS Classement\n    FROM FACT_Ventes v\n    JOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\n    JOIN DIM_Client c ON v.Client_Key = c.Client_Key\n    GROUP BY p.Produit_Key, c.Client_Key, p.Catégorie\n) r ON v.Produit_Key = r.Produit_Key AND v.Client_Key = r.Client_Key\nWHERE d.Année = 2024\nGROUP BY p.Catégorie;\n```\n\n---\n\n## 2.5 Atelier Pratique : Conception d'un Modèle Ventes\n\n### 2.5.1 Cas d'Étude : RetailCorp\n\n**Contexte :**\n- Chaîne de distribution spécialisée\n- 100 magasins en Europe\n- E-commerce multi-canal\n- 1 million de clients actifs\n\n**Besoins Analytiques :**\n1. Analyse des ventes par région, magasin, catégorie produit\n2. Suivi de la performance des vendeurs\n3. Analyse du comportement client (RFM)\n4. Prévision des ventes et optimisation des stocks\n\n### 2.5.2 Conception du Modèle Dimensionnel\n\n**Exercice 1 : Identifier les Dimensions et Faits (20 min)**\n\n```sql\n-- Schéma conceptuel à concevoir\n-- Dimensions identifiées :\n-- ✓ DIM_Date (déjà conçue)\n-- ✓ DIM_Produit (avec hiérarchie Catégorie > Sous-catégorie > Produit)\n-- ✓ DIM_Client (avec segmentation RFM)\n-- ✓ DIM_Magasin (avec hiérarchie Pays > Région > Ville > Magasin)\n-- ✓ DIM_Vendeur (avec rattachement magasin)\n-- ✓ DIM_Temps (heure de la journée)\n\n-- Table de faits :\n-- ✓ FACT_Ventes (granularité : ligne de ticket de caisse)\n```\n\n**Exercice 2 : Créer le Script de Déploiement (30 min)**\n\n```sql\n-- Dimension Client avec SCD Type 2\nCREATE TABLE DIM_Client (\n    Client_Key INT PRIMARY KEY IDENTITY(1,1),\n    Code_Client VARCHAR(20) NOT NULL,\n    Nom VARCHAR(100) NOT NULL,\n    Prénom VARCHAR(100) NOT NULL,\n    Email VARCHAR(255),\n    Téléphone VARCHAR(20),\n    Adresse VARCHAR(255),\n    Code_Postal VARCHAR(10),\n    Ville VARCHAR(100),\n    Pays VARCHAR(50),\n    \n    -- Scores RFM\n    Score_Récence INT,\n    Score_Fréquence INT,\n    Score_Montant INT,\n    Segment_RFM VARCHAR(20),\n    \n    -- SCD Type 2\n    Date_Début DATE NOT NULL,\n    Date_Fin DATE NOT NULL,\n    Version_Active BIT NOT NULL DEFAULT 1,\n    Hash_Attributs BINARY(16)\n);\n\n-- Dimension Produit avec hiérarchie\nCREATE TABLE DIM_Produit (\n    Produit_Key INT PRIMARY KEY IDENTITY(1,1),\n    SKU VARCHAR(50) NOT NULL UNIQUE,\n    Nom_Produit VARCHAR(200) NOT NULL,\n    Description TEXT,\n    Catégorie VARCHAR(100) NOT NULL,\n    Sous_Catégorie VARCHAR(100) NOT NULL,\n    Marque VARCHAR(100),\n    Prix_Unitaire DECIMAL(10,2),\n    Coût_Unitaire DECIMAL(10,2),\n    Unité_Mesure VARCHAR(20),\n    Code_EAN VARCHAR(13),\n    \n    -- SCD Type 2 pour les changements de catégorie/prix\n    Date_Début DATE NOT NULL,\n    Date_Fin DATE NOT NULL,\n    Version_Active BIT NOT NULL DEFAULT 1\n);\n\n-- Table de faits Ventes\nCREATE TABLE FACT_Ventes (\n    Vente_Key BIGINT PRIMARY KEY IDENTITY(1,1),\n    -- Clés étrangères\n    Date_Key INT NOT NULL,\n    Temps_Key INT NOT NULL,\n    Produit_Key INT NOT NULL,\n    Client_Key INT NOT NULL,\n    Magasin_Key INT NOT NULL,\n    Vendeur_Key INT NOT NULL,\n    Promotion_Key INT,\n    \n    -- Mesures\n    Quantité INT NOT NULL,\n    Prix_Unitaire DECIMAL(10,2) NOT NULL,\n    Montant_HT DECIMAL(10,2) NOT NULL,\n    Montant_TTC DECIMAL(10,2) NOT NULL,\n    Coût_Unitaire DECIMAL(10,2),\n    Marge_Unitaire DECIMAL(10,2),\n    Remise_Pourcent DECIMAL(5,2),\n    Remise_Montant DECIMAL(10,2),\n    \n    -- Clés naturelles pour audit\n    Numéro_Ticket VARCHAR(50),\n    Ligne_Ticket INT,\n    \n    -- Contraintes\n    CONSTRAINT FK_Ventes_Date FOREIGN KEY (Date_Key) REFERENCES DIM_Date(Date_Key),\n    CONSTRAINT FK_Ventes_Produit FOREIGN KEY (Produit_Key) REFERENCES DIM_Produit(Produit_Key),\n    CONSTRAINT FK_Ventes_Client FOREIGN KEY (Client_Key) REFERENCES DIM_Client(Client_Key),\n    CONSTRAINT FK_Ventes_Magasin FOREIGN KEY (Magasin_Key) REFERENCES DIM_Magasin(Magasin_Key),\n    CONSTRAINT FK_Ventes_Vendeur FOREIGN KEY (Vendeur_Key) REFERENCES DIM_Vendeur(Vendeur_Key)\n);\n\n-- Index pour performances\nCREATE INDEX IX_Ventes_Date ON FACT_Ventes(Date_Key);\nCREATE INDEX IX_Ventes_Produit ON FACT_Ventes(Produit_Key);\nCREATE INDEX IX_Ventes_Client ON FACT_Ventes(Client_Key);\nCREATE INDEX IX_Ventes_Magasin ON FACT_Ventes(Magasin_Key);\nCREATE INDEX IX_Ventes_Date_Produit ON FACT_Ventes(Date_Key, Produit_Key);\n```\n\n### 2.5.3 Requêtes Analytiques Avancées\n\n**Exercice 3 : Développer les KPI Métier (40 min)**\n\n```sql\n-- 1. Analyse RFM des clients\nWITH RFM_Base AS (\n    SELECT\n        c.Client_Key,\n        c.Nom,\n        c.Prénom,\n        -- Récence (jours depuis dernière achat)\n        DATEDIFF(DAY, MAX(d.Date_Complete), GETDATE()) AS Récence,\n        -- Fréquence (nombre d'achats sur 12 mois)\n        COUNT(DISTINCT v.Date_Key) AS Fréquence,\n        -- Montant (CA total sur 12 mois)\n        SUM(v.Montant_HT) AS Montant\n    FROM FACT_Ventes v\n    JOIN DIM_Client c ON v.Client_Key = c.Client_Key\n    JOIN DIM_Date d ON v.Date_Key = d.Date_Key\n    WHERE d.Date_Complete >= DATEADD(MONTH, -12, GETDATE())\n    GROUP BY c.Client_Key, c.Nom, c.Prénom\n),\nRFM_Scores AS (\n    SELECT\n        *,\n        -- Scores de 1 à 5 (1=meilleur pour récence, 5=meilleur pour fréquence/montant)\n        NTILE(5) OVER (ORDER BY Récence DESC) AS Score_Récence,\n        NTILE(5) OVER (ORDER BY Fréquence ASC) AS Score_Fréquence,\n        NTILE(5) OVER (ORDER BY Montant ASC) AS Score_Montant\n    FROM RFM_Base\n)\nSELECT\n    Client_Key,\n    Nom,\n    Prénom,\n    Récence,\n    Fréquence,\n    Montant,\n    Score_Récence,\n    Score_Fréquence,\n    Score_Montant,\n    -- Score RFM combiné\n    CONCAT(Score_Récence, Score_Fréquence, Score_Montant) AS Score_RFM,\n    -- Segmentation RFM\n    CASE \n        WHEN CONCAT(Score_Récence, Score_Fréquence, Score_Montant) IN ('111','112','121','122','211','212','221','222') \n            THEN 'Champions'\n        WHEN Score_Récence IN (1,2) AND Score_Fréquence IN (3,4,5) AND Score_Montant IN (3,4,5)\n            THEN 'Clients Fidèles'\n        WHEN Score_Récence = 1 AND Score_Fréquence IN (1,2) AND Score_Montant IN (1,2)\n            THEN 'Nouveaux Clients'\n        WHEN Score_Récence IN (3,4) AND Score_Fréquence IN (1,2) AND Score_Montant IN (1,2)\n            THEN 'Clients à Risque'\n        WHEN Score_Récence = 5 \n            THEN 'Clients Perdus'\n        ELSE 'Clients Réguliers'\n    END AS Segment_RFM\nFROM RFM_Scores;\n\n-- 2. Analyse de la performance des magasins\nWITH Performance_Magasins AS (\n    SELECT\n        m.Nom_Magasin,\n        m.Ville,\n        m.Région,\n        COUNT(DISTINCT v.Client_Key) AS Clients_Uniques,\n        COUNT(DISTINCT v.Date_Key) AS Jours_Activité,\n        SUM(v.Montant_HT) AS CA_Total,\n        SUM(v.Quantité) AS Quantité_Total,\n        SUM(v.Montant_HT - (v.Quantité * v.Coût_Unitaire)) AS Marge_Brute,\n        COUNT(DISTINCT v.Vente_Key) AS Nombre_Ventes,\n        -- CA par m²\n        CASE \n            WHEN m.Surface_M2 > 0 \n            THEN SUM(v.Montant_HT) / m.Surface_M2 \n            ELSE 0 \n        END AS CA_Par_M2,\n        -- Panier moyen\n        CASE \n            WHEN COUNT(DISTINCT v.Vente_Key) > 0 \n            THEN SUM(v.Montant_HT) / COUNT(DISTINCT v.Vente_Key) \n            ELSE 0 \n        END AS Panier_Moyen\n    FROM FACT_Ventes v\n    JOIN DIM_Magasin m ON v.Magasin_Key = m.Magasin_Key\n    JOIN DIM_Date d ON v.Date_Key = d.Date_Key\n    WHERE d.Année = 2024\n    GROUP BY m.Magasin_Key, m.Nom_Magasin, m.Ville, m.Région, m.Surface_M2\n)\nSELECT\n    *,\n    RANK() OVER (ORDER BY CA_Total DESC) AS Classement_CA,\n    RANK() OVER (ORDER BY Marge_Brute DESC) AS Classement_Marge,\n    RANK() OVER (ORDER CA_Par_M2 DESC) AS Classement_Rentabilité\nFROM Performance_Magasins\nORDER BY CA_Total DESC;\n\n-- 3. Analyse des ventes croisées (Market Basket Analysis)\nWITH Produits_Achetés AS (\n    SELECT\n        v.Numéro_Ticket,\n        p.Produit_Key,\n        p.Nom_Produit,\n        p.Catégorie\n    FROM FACT_Ventes v\n    JOIN DIM_Produit p ON v.Produit_Key = p.Produit_Key\n    WHERE v.Date_Key BETWEEN 20240101 AND 20241231\n),\nCombinaisons_Produits AS (\n    SELECT\n        p1.Nom_Produit AS Produit_A,\n        p2.Nom_Produit AS Produit_B,\n        COUNT(DISTINCT p1.Numéro_Ticket) AS Occurrences_Conjointes,\n        COUNT(DISTINCT p1.Numéro_Ticket) * 1.0 / (\n            SELECT COUNT(DISTINCT Numéro_Ticket) \n            FROM Produits_Achetés \n            WHERE Nom_Produit = p1.Nom_Produit\n        ) AS Confiance\n    FROM Produits_Achetés p1\n    JOIN Produits_Achetés p2 ON p1.Numéro_Ticket = p2.Numéro_Ticket\n    WHERE p1.Produit_Key <> p2.Produit_Key\n    GROUP BY p1.Nom_Produit, p2.Nom_Produit\n)\nSELECT\n    Produit_A,\n    Produit_B,\n    Occurrences_Conjointes,\n    Confiance\nFROM Combinaisons_Produits\nWHERE Occurrences_Conjointes >= 10\n  AND Confiance >= 0.1\nORDER BY Occurrences_Conjointes DESC, Confiance DESC;\n```\n\n---\n\n## 2.6 Optimisation des Performances\n\n### 2.6.1 Stratégies d'Indexation\n\n**Index Clustered vs Non-Clustered :**\n\n```sql\n-- Index clustered sur la table de faits (généralement sur la clé primaire)\nCREATE CLUSTERED INDEX IX_FACT_Ventes_Key ON FACT_Ventes(Vente_Key);\n\n-- Index non-clustered sur les clés étrangères\nCREATE NONCLUSTERED INDEX IX_FACT_Ventes_Date ON FACT_Ventes(Date_Key);\nCREATE NONCLUSTERED INDEX IX_FACT_Ventes_Produit ON FACT_Ventes(Produit_Key);\nCREATE NONCLUSTERED INDEX IX_FACT_Ventes_Client ON FACT_Ventes(Client_Key);\n\n-- Index couvrant pour requêtes fréquentes\nCREATE NONCLUSTERED INDEX IX_FACT_Ventes_Couvert \nON FACT_Ventes (Date_Key, Produit_Key)\nINCLUDE (Montant_HT, Quantité, Client_Key);\n\n-- Index sur colonnes calculées pour la recherche\nCREATE NONCLUSTERED INDEX IX_DIM_Client_Recherche \nON DIM_Client (Nom, Prénom, Ville)\nINCLUDE (Email, Téléphone);\n```\n\n### 2.6.2 Partitionnement des Tables\n\n**Partitionnement par Date :**\n\n```sql\n-- Création de la fonction de partitionnement\nCREATE PARTITION FUNCTION pf_Ventes_Par_Mois (INT)\nAS RANGE RIGHT FOR VALUES (\n    20240101, 20240201, 20240301, 20240401,\n    20240501, 20240601, 20240701, 20240801,\n    20240901, 20241001, 20241101, 20241201\n);\n\n-- Création du schéma de partitionnement\nCREATE PARTITION SCHEME ps_Ventes_Par_Mois\nAS PARTITION pf_Ventes_Par_Mois\nALL TO ([PRIMARY]);\n\n-- Recréation de la table de faits partitionnée\nCREATE TABLE FACT_Ventes_Partitionnée (\n    Vente_Key BIGINT IDENTITY(1,1),\n    Date_Key INT NOT NULL,\n    -- ... autres colonnes\n    CONSTRAINT PK_FACT_Ventes_Part PRIMARY KEY (Date_Key, Vente_Key)\n) ON ps_Ventes_Par_Mois(Date_Key);\n```\n\n### 2.6.3 Stratégies de Compression\n\n```sql\n-- Activation de la compression de page\nALTER TABLE FACT_Ventes REBUILD PARTITION = ALL\nWITH (DATA_COMPRESSION = PAGE);\n\n-- Pour les archives, compression plus agressive\nALTER TABLE FACT_Ventes_Archive \nREBUILD WITH (DATA_COMPRESSION = ROW);\n\n-- Vérification des gains de compression\nSELECT \n    t.name AS TableName,\n    i.name AS IndexName,\n    p.partition_number,\n    p.data_compression_desc,\n    p.rows\nFROM sys.partitions p\nJOIN sys.tables t ON p.object_id = t.object_id\nJOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id\nWHERE t.name = 'FACT_Ventes';\n```\n\n---\n\n## 2.7 Synthèse du Module 2 et Points Clés\n\n### 2.7.1 Récapitulatif des Concepts\n\nÀ l'issue de ce module, les participants maîtrisent :\n\n✅ **La modélisation dimensionnelle** : faits, dimensions, modèles en étoile/flocon/constellation  \n✅ **Les techniques d'historisation** : SCD Type 2 pour le suivi des changements  \n✅ **Le SQL analytique avancé** : fonctions fenêtrées, agrégations, requêtes complexes  \n✅ **L'optimisation des performances** : indexation, partitionnement, compression  \n✅ **La conception de modèles robustes** : bonnes pratiques et pièges à éviter  \n\n### 2.7.2 Checklist de Fin de Module\n\n**Auto-évaluation des Acquis :**\n\n- [ ] Je peux concevoir un modèle en étoile pour un processus métier\n- [ ] Je comprends la différence entre SCD Type 1, 2 et 3\n- [ ] Je maîtrise les fonctions fenêtrées (RANK, LAG, LEAD)\n- [ ] Je sais optimiser les performances d'un modèle dimensionnel\n- [ ] Je peux écrire des requêtes analytiques complexes\n- [ ] Je comprends les stratégies d'indexation et de partitionnement\n\n### 2.7.3 Projet Pratique Final\n\n**Mission :** Concevoir et implémenter un modèle dimensionnel complet pour un cas de vente au détail, incluant :\n\n1. Modèle conceptuel et logique\n2. Scripts de création des tables\n3. Requêtes analytiques pour 5 KPI métier\n4. Stratégie d'optimisation des performances\n5. Documentation technique\n\n**Livrables :**\n- Schémas de base de données\n- Scripts SQL complets\n- Documentation des règles de gestion\n- Plan de tests de performance\n\n---",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}